//#############
// This file or equiv was possibly autogenerated for STM32VL BOARD but was not
// autogenerated for the stmcube with just the STM32F100RBTx
// Since we still wanted to blink the LED's it was hand inserted,
// into the I2C_100Khz and I2C_Uart_WithInterupts projects.
//#############
/*
 * led.c
 *
 *  Created on: Oct 2, 2017
 *      Author: jmk
 *
 *      Somewhat adapted from "stm32vldiscovery.c"
 *      but rather to use HAL functions to control the
 *      two LED's on the STM-32VL board
 *
 */

/*
 * #######################################################
 * Basic facts of this this hardware:
 *
 * LED 3 Green, (LD3) is on port PC9
 * LED 4 Blue, (LD4) is on port PC8
 *
 * These LEDS are one when the ports are driven high (1)
 *
 * ########################################################
 */
#include "stm32f1xx_hal.h"
#include "led.h"

const uint16_t GPIO_PIN[LEDn] 		= {LD3_Green_Pin, LD4_Blue_Pin};
const uint16_t BUTTON_PIN[BUTTONn] 	= {BlueButton_Pin};

GPIO_TypeDef* BUTTON_PORT[BUTTONn] = {BlueButton_GPIO_Port};

// Not needed since have it all done by "MX_GPIO_Init(void)"
//void STM32vldisc_LEDInit(Led_TypeDef Led)

// This morphs to Hal model:
void STM32vldisc_LEDOn(Led_TypeDef Led)
{
	HAL_GPIO_WritePin(GPIOC, GPIO_PIN[Led], GPIO_PIN_SET);
}

void STM32vldisc_LEDOff(Led_TypeDef Led)
{
	//GPIO_PORT[Led]->BRR = GPIO_PIN[Led];
	HAL_GPIO_WritePin(GPIOC, GPIO_PIN[Led], GPIO_PIN_RESET);
}

void STM32vldisc_LEDToggle(Led_TypeDef Led)
{
  //GPIO_PORT[Led]->ODR ^= GPIO_PIN[Led];
  HAL_GPIO_TogglePin(GPIOC, GPIO_PIN[Led]);
}

// Not needed since have it all done by "MX_GPIO_Init(void)"
// But maybe a bit less sophisticated..
/*
void STM32vldisc_PBInit(Button_TypeDef Button, ButtonMode_TypeDef Button_Mode)
{
  GPIO_InitTypeDef GPIO_InitStructure;
  EXTI_InitTypeDef EXTI_InitStructure;
  NVIC_InitTypeDef NVIC_InitStructure;

   Enable the BUTTON Clock
  RCC_APB2PeriphClockCmd(BUTTON_CLK[Button] | RCC_APB2Periph_AFIO, ENABLE);

   Configure Button pin as input floating
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
  GPIO_InitStructure.GPIO_Pin = BUTTON_PIN[Button];
  GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStructure);

  if (Button_Mode == BUTTON_MODE_EXTI)
  {
     Connect Button EXTI Line to Button GPIO Pin
    GPIO_EXTILineConfig(BUTTON_PORT_SOURCE[Button], BUTTON_PIN_SOURCE[Button]);

     Configure Button EXTI line
    EXTI_InitStructure.EXTI_Line = BUTTON_EXTI_LINE[Button];
    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;

    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;

    EXTI_InitStructure.EXTI_LineCmd = ENABLE;
    EXTI_Init(&EXTI_InitStructure);

     Enable and set Button EXTI Interrupt to the lowest priority
    NVIC_InitStructure.NVIC_IRQChannel = BUTTON_IRQn[Button];
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x0F;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x0F;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;

    NVIC_Init(&NVIC_InitStructure);
  }
}
*/

/**
  * @brief  Returns the selected Button state.
  * @param  Button: Specifies the Button to be checked.
  *   This parameter can be one of following parameters:
  *     @arg BUTTON_USER: USER Push Button
  * @retval The Button GPIO pin value.
  */
uint32_t STM32vldisc_PBGetState(Button_TypeDef Button)
{
  //return GPIO_ReadInputDataBit(BUTTON_PORT[Button], BUTTON_PIN[Button]);
	GPIO_PinState pinState;
	pinState = HAL_GPIO_ReadPin(BUTTON_PORT[Button], BUTTON_PIN[Button]);
	return (pinState == GPIO_PIN_RESET) ? (uint32_t) 0 : (uint32_t) 1;
}

